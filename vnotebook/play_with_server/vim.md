# VIM Notes

记录一些 `VIM` 技巧。

## 模式 (MODE)

### 正常模式 `NORMAL MODE`

| 基础命令 | 说明                                |
| -------- | ----------------------------------- |
| `h`      | 左                                  |
| `j`      | 下                                  |
| `k`      | 上                                  |
| `l`      | 右                                  |
| `e`/`E`  | 光标移至当前词（`word`/`WORD`）尾   |
| `w`/`W`  | 光标移至下一个词（`word`/`WORD`）首 |
| `b`/`B`  | 光标移至上一个词（`word`/`WORD`）首 |
| `i`      | 在当前字符前进入插入模式            |
| `a`      | 在当前字符后进入插入模式            |
| `R`      | 在当前字符进入替换模式              |
| `gR`     | 在当前字符进入虚拟替换模式          |
| `$`      | 光标移至行尾                        |
| `^`      | 光标移至行首                        |
| `gg`     | 光标移至文档开头                    |
| `G`      | 光标移至文档末尾                    |

> 注：替换模式中，把制表符当作一个字符。而在虚拟替换模式中，是按屏幕上实际显示的宽度来替换字符的，而不是按文件中所保存的字符进行替换。假设制表符占屏幕 8 列宽，那么在输入前 7 个字符时，每个字符都会被插入到制表符之前，最后，当输入了第 8 个字符时，该字符将会替换制表符。
>
> `word`：理解意义上的词。
>
> `WORD`：一串非空字符。

`r{char}`：单次版本的替换模式，允许覆盖一个字符，之后马上又回到普通模式。

`gr{char}`：单次版本的虚拟替换模式。

| 复合命令 | 等效的长命令 | 说明                                   |
| -------- | ------------ | -------------------------------------- |
| `C`      | `c$`         | 删除当前字符至行末，并进入插入模式     |
| `s`      | `cl`         | 删除当前字符，并进入插入模式           |
| `S`      | `^C`         | 删除当前行，并进入插入模式             |
| `I`      | `^i`         | 移动至行首，并进入插入模式             |
| `A`      | `$a`         | 移动至行尾，并进入插入模式             |
| `o`      | `A<CR>`      | 在该行下面增加一空白行，并进入插入模式 |
| `O`      | `ko`         | 在该行上面增加一空白行，并进入插入模式 |
| `x`      | `dl`         | 删除当前字符，同 `<Del>`键             |
| `X`      | `dh`         | 删除当前光标前一个字符                 |

| 目的                     | 操作                    | 重复 | 回退 |
| ------------------------ | ----------------------- | ---- | ---- |
| 做出一个修改             | `{edit}`                | `.`  | `u`  |
| 在行内查找下一指定字符   | `f{char}`/`t{char}`     | `;`  | `,`  |
| 在行内查找上一指定字符   | `F{char}`/`T{char}`     | `;`  | `,`  |
| 在文档中查找下一处匹配项 | `\pattern<CR>`          | `n`  | `N`  |
| 在文档中查找上一处匹配项 | `?pattern<CR>`          | `n`  | `N`  |
| 执行替换                 | `:s/target/replacement` | `&`  | `u`  |
| 执行一系列修改           | `qx{changes}q`          | `@x` | `u`  |

> 注：`f{char}` 和 `t{char}` 的区别：`f{char}` 查找到指定字符后，光标停留在该字符上，`t{char}` 查找到指定字符后，光标停留在该字符前。

`.` 命令：重复上次修改。

`u`命令：撤销上次的修改。

> 注：在插入模式中输入或删除一些文本直至退回至普通模式算是一次修改，在插入模式中移动光标会重置修改状态。

`f{char}`命令：查找当前行下一处指定字符出现的位置，如果找到了，就直接把光标移动到那里。

`;`命令：重复查找上次`f`命令所查找的字符。

`,`命令：反向查找上次`f`命令所查找的字符。

`*`命令：查找当前光标下的单词。

`dw`：删除当前光标处直至下一个词前。

`cw`：删除当前光标处直至下一个词前，并进入插入模式。

`daw`：删除当前光标所在单词，`aw`表示文本对象。

`caw`：删除当前光标所在单词，并进入插入模式。

`ga`：查看光标所在处的字符的字符编码，包括十进制和十六进制。

`<C-a>/<C-x>`命令：对数字执行加/减法操作。在不带次数执行时，它们会逐个加/减，但如果带一个次数前缀，那么就可以用它们加减任意整数。如果光标不在数字上，则会在当前行正向查找一个数字，如果找到了，就径直跳到那里，并执行操作。

> 注：Vim 把以 0 开头的数字解释为八进制值，而不是十进制，007 + 001 = 010，可以在 `.vimrc` 文件中设置 `set nrformats=`，将所有数字都当成十进制。

---

> 操作符 + 动作命令 = 操作

`d{motion}` 命令可以对一个字符（`dl`）、一个完整的单词（`daw`）或一整个段落（`dap`）进行操作，它作用的范围由动作命令决定。`c{motion}`、`y{motion}`以及其他一些命令也类似，统称为操作符（operator）。

`Vim` 的常用操作符命令：

| 命令 | 说明                                   |
| ---- | -------------------------------------- |
| `c`  | 修改（将进入插入模式）                 |
| `d`  | 删除                                   |
| `y`  | 复制到寄存器                           |
| `g~` | 反转大小写                             |
| `gu` | 转换为小写                             |
| `gU` | 转换为大写                             |
| `>`  | 增加缩进                               |
| `<`  | 减少缩进                               |
| `=`  | 自动缩进                               |
| `!`  | 使用外部程序过滤 `{motion}` 所跨越的行 |

> 数字 + 操作 = 重复操作

### 插入模式 `INSERT MODE`

| 按键操作 | 用途                       |
| -------- | -------------------------- |
| `<C-h>`  | 删除前一个字符（同退格键） |
| `<C-w>`  | 删除前一个单词             |
| `<C-u>`  | 删至行首                   |

> 注：这些命令不是 `Vim` 所独有的，在 `Vim` 的命令行模式中，以及在 `bash shell` 中，也可以使用它们。

切换回普通模式：

| 按键操作 | 用途                            |
| -------- | ------------------------------- |
| `<Esc>`  | 切换到普通模式                  |
| `<C-[>`  | 切换到普通模式，与 `<Esc>` 等效 |
| `<C-o>`  | 切换到插入-普通模式             |

`插入-普通模式`：是普通模式的一个特例，它能让我们执行一次普通模式命令。在此模式中，我们可以执行一个普通模式命令，执行完后，马上就又返回到插入模式。

`<C-r>{register}`：可以在插入模式中粘贴寄存器 `{register}` 中的内容，但是可能会出现不必要的换行或额外的缩进。

`<C-r><C-p>{register}`：与 `<C-r>{register}` 功能类似，但是是按原义插入寄存器内的文本。

`<C-r>={expr}<CR>`：用 `=` 指明使用表达式寄存器，该命令可以执行数学表达式 `{expr}`，并把结果插入到文档的当前位置。

插入非常用字符：

| 按键操作              | 用途                                       |
| --------------------- | ------------------------------------------ |
| `<C-v>{123}`          | 以十进制字符编码插入字符                   |
| `<C-v>u{1234}`        | 以十六进制字符编码插入字符                 |
| `<C-v>{nondigit}`     | 按原义插入非数字字符                       |
| `<C-k>{char1}{char2}` | 插入以二合字母 `{char1}{char2}` 表示的字符 |

二合字母（digraph）：使用成对的字符来描述非常用字符，可以通过 `:h digraph-table` 查看所支持的字符。

### 可视模式 `VISUAL MODE`

可视模式允许我们选中一个文本区域并在其上操作。`Vim` 具有 3 种不同的可视模式，分别用于操作字符文本、行文本和块文本。

某些可视模式命令执行的基本功能与普通模式相同，但操作上有些细微的变化。在普通模式中，我们先触发修改命令，然后使用动作命令指定其作用范围，然而，在可视模式中，我们先选中选区，然后再触发修改命令。

激活可视模式：

| 命令    | 用途                   |
| ------- | ---------------------- |
| `v`     | 激活面向字符的可视模式 |
| `V`     | 激活面向行的可视模式   |
| `<C-v>` | 激活面向块的可视模式   |
| `gv`    | 重选上次的高亮选区     |

`o`：高亮选区的范围由其两个端点界定。其中一段固定，而另一端可以随光标自由移动，可以用该键来切换其活动的端点。

`.`：在使用该命令重复一条可视模式命令时，它所操作的文本数量和上次被高亮选中的文本数量相同。

> 注：该命令在面向字符的高亮选区时，可能会产生令人意外的结果。

编辑表格数据、修改列文本、在长短不一的高亮块后添加文本，均可用面向块的可视模式实现。

`I`：将光标置于选区的开头

`A`：将光标置于选区的结尾

在可视模式中，`i`和 `a` 会被当作一个文本对象的组成部分。

### 命令行模式 `COMMAND MODE`

`:`：`Vim` 会切换到命令行模式，可以输入一条命令，然后按 `<CR>` 执行它。

`@:`：重复上次的 `Ex` 命令。

操作缓冲区文本的 `Ex` 命令：

| 命令                                            | 用途                                                          |
| ----------------------------------------------- | ------------------------------------------------------------- |
| `:[range]delete [x]`                            | 删除指定范围内的行[到寄存器 x 中]                             |
| `:[range]yank [x]`                              | 复制指定范围的行[到寄存器 x 中]                               |
| `:[line]put [x]`                                | 在指定行后粘贴寄存器 x 中的内容                               |
| `:[range]copy {address}`                        | 把指定范围内的行拷贝到 {address} 所制定的行之下               |
| `:[range]move {address}`                        | 把指定范围内的行移动到 {address} 所指定的行之下               |
| `:[range]join`                                  | 连接指定范围内的行                                            |
| `:[range]normal {commands}`                     | 对指定范围内的每一行执行普通模式命令 {command}                |
| `:[range]substitute/{pattern}/{string}/{flags}` | 把指定范围内出现 {pattern} 的地方替换为 {string}              |
| `:[range]global/{pattern}/[cmd]`                | 对指定范围内匹配 {pattern} 的所有行，在其上执行 Ex 命令 {cmd} |

> 注：`[range]` 通常为 `{start}, {end}`。`.` 代表当前行的地址，`%` 代表当前文件中的所有行，`$` 代表文档最后一行，`'<` 代表高亮选区首行的位置标记，`'>` 代表高亮选区的最后一行。

可以用偏移对地址进行修正，偏移的一般形式为：`:{address}+n`。

表示范围的符号：

| 符号 | 地址                          |
| ---- | ----------------------------- |
| `1`  | 文件的第一行                  |
| `$`  | 文件的最后一行                |
| `0`  | 虚拟行，位于文件第一行上方    |
| `.`  | 光标所在行                    |
| `'m` | 包含位置标记 m 的行           |
| `'<` | 高亮选区的起始行              |
| `'>` | 高亮选区的结束行              |
| `%`  | 整个文件（`:1,$` 的简写形式） |

`:copy` 命令：简写形式 `:t`，可以把一行或多行从文档的一部分复制到另一部分。

一些实用场景：

| 命令       | 用途                                             |
| ---------- | ------------------------------------------------ |
| `:6t.`     | 把第 6 行复制到当前行下方                        |
| `:t6`      | 把当前行复制到第 6 行下方                        |
| `:t.`      | 为当前行创建一个副本（类似于普通模式下的 `yyp`） |
| `:t$`      | 把当前行复制到文本结尾                           |
| `:'<,'>t0` | 把高亮选中的行复制到文件开头                     |

`:normal` 命令：在指定范围上执行普通模式命令。比如要注释全文，可以使用命令 `:%normal i//`，在文件每行的结尾都添加一个分号，`:%normal A;`。

`<C-r><C-w>`：会复制光标下的单词并把它插入到命令行中。

`<C-r><C-a>`：会复制光标下的字串并把它插入到命令行中。

回溯历史命令：先按 `:` 键切换到命令行模式，在保持提示符为空的情况下按 `<Up>` 键，此时最后执行的那条 `Ex` 命令就会被填充到命令行上。再接着按 `<Up>` 键的话，就可以回到更早的 `Ex` 历史命令；按 `<Down>` 键的话，则会沿相反方向滚动。

`q:`：进入命令行窗口，其中的每行内容对应着命令历史中的一个条目，这里可以用 `k` 及 `j` 键在历史中向前或向后移动，也可以用 `Vim` 的查找功能查找某一行。在按下 `<CR>` 键时，将会把当前行的内容当成 `Ex` 命令加以执行。

打开命令行窗口的几种方式：

| 命令    | 用途                         |
| ------- | ---------------------------- |
| `q/`    | 打开查找命令历史的命令行窗口 |
| `q:`    | 打开 Ex 命令历史的命令行窗口 |
| `<C-f>` | 从命令行模式切换到命令行窗口 |

`:!{cmd}`：执行 shell 中的命令 {cmd}。

`:shell`：启动一个交互的 shell 会话，用 `exit` 命令可以退出此 shell 并返回 `Vim`。

`:read !{cmd}`：在 shell 中执行 {cmd}，并把其标准输出插入到光标下方。

`:write !sh`：在 shell 中执行当前缓冲区中的每行内容。

`:[range]write !{cmd}`：在 shell 中执行 {cmd}，以 [range] 作为其标准输入。

`:[range]!{filter}`：使用外部程序 {filter} 过滤指定的 [range]。

例如，可以用外部的 `sort` 命令对下列 CSV 文件中的记录进行排序：

| 命令                  | 文件状态                                                                                                              |
| --------------------- | --------------------------------------------------------------------------------------------------------------------- |
| {start}               | first name,last name,email<br>john,smith,john@example.com<br>drew,neil,drew@vimcasts.org<br>jane,doe,jane@example.com |
| `:2,$!sort -t',' -k2` | first name,last name,email<br>jane,doe,jane@example.com<br>drew,neil,drew@vimcasts.org<br>john,smith,john@example.com |

> 注：`-t','` 参数告诉 `sort` 命令，这些记录以逗号分隔，然后再用`-k2` 参数指定按第二个字段进行排序。

## 文件

### 管理多个文件

用缓冲区列表管理打开的文件。

`:ls`：会列出所有被载入到内存中的缓冲区的列表。

其中列出的信息中。`%` 符号指明哪个缓冲区在当前窗口中可见，而 `#` 符号则代表轮换文件。按 `<C-^>` 可以在当前文件和轮换文件间快速切换。

遍历缓冲区列表：

| 命令      | 说明                           |
| --------- | ------------------------------ |
| `:bprev`  | 在列表中反向移动，每次移动一项 |
| `:bnext`  | 在列表中正向移动，每次移动一项 |
| `:bfirst` | 跳到列表的开头                 |
| `:blast`  | 跳到列表的结尾                 |

`:buffer {N}`：直接凭编号跳转到一个缓冲区，该编号是在缓冲区创建时由 `Vim` 自动分配的，可通过 `:ls` 查看。

`:buffer {bufname}`：同样是直接跳转到一个缓冲区，{bufname} 只需包含文件路径中足以位移标识此缓冲区的字符即可。

`:bufdo`：可以在 `:ls` 列出的所有缓冲区上执行 `Ex` 命令。

`:[range]bdelete` 或 `:bdelete N1 N2 N3`：删除缓冲区。

可以用参数列表将缓冲区分组。

`:args`：会列出参数列表。

输出中的 `[]` 字符指明了参数列表中的哪个文件是活动文件。

`:args {arglist}`：设置参数列表的内容。`{arglist}` 可以包括文件名、通配符，甚至是一条 shell 命令的输出结果，shell 命令可用反撇号（`）括起来。

通配符是一个占位标记，它代表了可用于文件或目录名称的字符。`*` 符号用于匹配 0 个或多个字符，但它的范围仅局限于指定的目录，而不会递归其子目录。`**` 通配符也匹配 0 个或多个字符，但它可以递归进入指定目录的子目录。

通过使用 `:args {arglist}` 命令，一下就可以清空并重新设置参数列表，接着就可以用 `:next` 及 `:prev` 命令遍历参数列表中的文件，或是用 `:argdo` 命令在列表中的每个缓冲区上执行同一条命令。

> 注：当使用 `:argdo {cmd}` 或 `:bufdo {cmd}` 命令时，由于一个缓冲区文件发生改变未保存，`Vim` 会弹出错误信息，从而导致接下来的操作失败。可以通过启用 `hidden` 选项解决，该设置能让我们用一条 `:argdo` 或 `:bufdo` 命令就可以修改一组缓冲区。

`Vim` 可以将工作区切分为若干个窗口，在这些窗口里并排显示多个缓冲区。

把工作区切分为窗口的几种方式：

| 命令               | 用途                                        |
| ------------------ | ------------------------------------------- |
| `<C-w>s`           | 水平切分当前窗口，新窗口仍显示当前缓冲区    |
| `<C-w>v`           | 垂直切分当前窗口，新窗口仍显示当前缓冲区    |
| `:sp[lit] {file}`  | 水平切分当前窗口，并在新窗口中载入 `{file}` |
| `:vsp[lit] {file}` | 垂直切分当前窗口，并在新窗口中载入 `{file}` |

![分割窗口](https://gitee.com/KivenC/chaos/raw/master/upload_images/20200808154031.png)

在窗口间进行切换的命令：

| 命令     | 用途             |
| -------- | ---------------- |
| `<C-w>w` | 在窗口间循环切换 |
| `<C-w>h` | 切换到左边的窗口 |
| `<C-w>j` | 切换到下边的窗口 |
| `<C-w>k` | 切换到上边的窗口 |
| `<C-w>l` | 切换到右边的窗口 |

> 注：实际上，`<C-w><C-w>` 完成的功能和 `<C-w>w` 相同。上表中其它命令同样如此。

关闭窗口：

| Ex 命令    | 普通模式命令 | 用途                             |
| ---------- | ------------ | -------------------------------- |
| `:clo[se]` | `<C-w>c`     | 关闭活动窗口                     |
| `:on[ly]`  | `<C-w>o`     | 只保留活动窗口，关闭其他所有窗口 |

改变窗口大小及重新排列窗口：

| 命令        | 用途                        |
| ----------- | --------------------------- |
| `<C-w>=`    | 使所有窗口等宽、等高        |
| `<C-w>_`    | 最大化活动窗口的高度        |
| `<C-w>|`    | 最大化活动窗口的宽度        |
| `[N]<C-w>_` | 把活动窗口的高度设为 [N] 行 |
| `[N]<C-w>|` | 把活动窗口的宽度设为 [N] 行 |

用标签页将窗口分组，`Vim` 的标签页与缓冲区并非一一对应的关系。`Vim` 中的标签页更像是 Linux 中的虚拟桌面，利用标签页可以把工作分隔到不同的工作区。

`:lcd {path}`：设置当前窗口的本地工作目录。该命令只影响当前窗口，而非当前标签页。

`:windo lcd {path}`：为一个标签页中所有的窗口设置本地工作目录。

打开及关闭标签页：

| 命令                    | 用途                                 |
| ----------------------- | ------------------------------------ |
| `:tabe[dit] {filename}` | 在新标签页中打开 {filename}          |
| `<C-w>T`                | 把当前窗口移到一个新标签页           |
| `:tabc[lose]`           | 关闭当前标签页及其中的所有窗口       |
| `:tabo[nly]`            | 只保留活动标签页，关闭所有其它标签页 |

标签页的编号从 1 开始，在标签页间的切换命令：

| Ex 命令          | 普通模式命令 | 用途                      |
| ---------------- | ------------ | ------------------------- |
| `:tabn[ext] {N}` | `{N}gt`      | 切换到编号为 {N} 的标签页 |
| `:tabn[ext]`     | `gt`         | 切换到下一标签页          |
| `:tabp[revious]` | `gT`         | 切换到上一标签页          |

`:tabmove [N]`：重新排列当前标签页。当 [N] 为 0 时，当前标签页会被移到开头，如果省略了 [N]，当前标签页会被移到结尾。

### 打开及保存文件

`:edit {file}`：允许通过文件的绝对路径或相对路径来打开文件。

`:pwd`：打印工作目录，和 bash 是一样的。

`:edit %<Tab>`：% 符号代表活动缓冲区的完整文件路径，按 `<Tab>` 键会将其展开，使之显示为活动缓冲区的完整文件路径。

`:edit %:h<Tab>`：`:h` 修饰符会去除文件名，但保留路径中的其它部分，因此该命令会展开为当前文件所在目录的路径。

`:find {file}`：允许通过文件名打开一个文件，但无需输入该文件的完整路径。

可以通过 `:set path+={path}` 来配置 path 选项。

netrw -- Vim 原生的文件管理器，当打开一个指向目录的路径而不是文件路径时，就会打开一个文件管理器窗口，在这里，可以用普通 `Vim` 缓冲区中可用的所有动作命令来浏览目录列表。

打开文件管理器：

| Ex 命令    | 缩写  | 用途                                                             |
| ---------- | ----- | ---------------------------------------------------------------- |
| `:edit .`  | `:e.` | 打开文件管理器，并显示当前工作目录                               |
| `:Explore` | `:E`  | 打开文件管理器，并显示活动缓冲区所在的目录<br>相当于 `:edit %:h` |

netrw 插件不仅可以浏览文件系统， 还可以创建新文件(`:h netrw-%`)及目录(`:h netrw-d`)，重命名已有的文件及目录(`:h netrw-rename`)，或是删除它们(`:h netrw-del`)。还可以通过网络读写文件(`:h netrw-ref`)。

`:w !sudo tee % > /dev/null`：以超级用户权限保存文件。在 `Vim` 中，`%` 符号具有特殊含义，会展开成当前文件的完整路径，该条命令的后半部分会把缓冲区的内容当作标准输入，并用它来覆盖当前文件的内容。所以 `Vim` 会提示我们作出选择，是要保留缓冲区中的版本，还是载入磁盘上的版本。

## 更快地移动及跳转

### 用动作命令在文档中移动

可查阅 `Vim` 文档中的 `:h motion.txt`，以获得一个完整的动作命令列表。

操作实际行和屏幕行的命令：

| 命令 | 光标动作                       |
| ---- | ------------------------------ |
| `j`  | 向下移动一个实际行             |
| `gj` | 向下移动一个屏幕行             |
| `k`  | 向上移动一个实际行             |
| `gk` | 向上移动一个屏幕行             |
| `0`  | 移动到实际行的行首             |
| `g0` | 移动到屏幕行的行首             |
| `^`  | 移动到实际行的第一个非空白字符 |
| `g^` | 移动到屏幕行的第一个非空白字符 |
| `$`  | 移动到实际行的行尾             |
| `g$` | 移动到屏幕行的行尾             |

基于单词的移动命令：

| 命令 | 光标动作                          |
| ---- | --------------------------------- |
| `w`  | 正向移动到下一单词的开头          |
| `b`  | 反向移动到当前单词/上一单词的开头 |
| `e`  | 正向移动到当前单词/下一单词的词尾 |
| `ge` | 反向移动到上一单词的结尾          |

单词（word）：由字母、数字、下划线，或其它非空白字符的序列组成，单词间以空白字符分隔。

字串（WORD）：由非空白字符序列组成，字串间以空白字符分隔。每个面向单词的动作命令，都有一个面向字串的命令与其对应，这当中包括 `W`、`B`、`E`、和 `gE`。

利用 `f{char}`、`t{char}` 等命令查找字符，移动光标。

利用 `/pattern<CR>` 查找一个以上的字符，或是移动到当前行之外。

分隔符文本对象：

| 文本对象         | 选择区域                          |
| ---------------- | --------------------------------- |
| `a)` 或 `ab`     | 一对圆括号 (parentheses)          |
| `i)` 或 `ib`     | 圆括号 (parentheses) 内部         |
| `a}` 或 `aB`     | 一对花括号 {braces}               |
| `i}` 或 `iB`     | 花括号 {braces} 内部              |
| `a]`             | 一对方括号 [brackets]             |
| `i]`             | 方括号 [brackets] 内部            |
| `a>`             | 一对尖括号 \<angle brackets\>     |
| `i>`             | 尖括号 \<angle brackets\> 内部    |
| `a'`             | 一对单引号 'single quotes'        |
| `i'`             | 单引号 'single quotes' 内部       |
| `a"`             | 一对双引号 "double quotes"        |
| `i"`             | 双引号 "double quotes" 内部       |
| <code>a\`</code> | 一对反引号 \`backticks\`          |
| <code>i\`</code> | 反引号 \`backticks\` 内部         |
| `at`             | 一对 XML 标签 \<xml\>tags\</xml\> |
| `it`             | XML 标签内部                      |

> 注：文本对象本身并不是动作命令，我们不能用它们在文档中移动。但是我们却可以在可视模式及操作符待决模式中使用文本对象。

范围文本对象：

| 文本对象 | 选择范围           |
| -------- | ------------------ |
| `iw`     | 当前单词           |
| `aw`     | 当前单词及一个空格 |
| `iW`     | 当前字串           |
| `aW`     | 当前字串及一个空格 |
| `is`     | 当前句子           |
| `as`     | 当前句子及一个空格 |
| `ip`     | 当前段落           |
| `ap`     | 当前段落及一个空行 |

一般来说，`d{motion}` 命令和 `aw`、`as`和`ap` 配合起来使用比较好，而 `c{motion}` 命令和 `iw` 及类似的文本对象一起用效果会更好。

`Vim` 的位置标记允许我们快速跳转到文档中感兴趣的地方。我们可以手动设置位置标记，不过 `Vim` 也会自动帮我们记录某些感兴趣的位置点。

`m{a-zA-Z}`：会用选定的字母标记当前光标所在位置。小写位置标记只在每个缓冲区里局部可见，而大写位置标记则全局可见。

<code>\`{mark}</code>：跳转到位置标记所在行，并把光标置于该行第一个非空白字符上。

`mm` 和 <code>\`m</code> 命令是一对便于使用的命令，分别设置位置标记 `m`，以及跳转到该标记。

`Vim` 的自动位置标记：

| 位置标记          | 跳转到                           |
| ----------------- | -------------------------------- |
| <code>\`\`</code> | 当前文件中上次跳转动作之前的位置 |
| <code>\`.</code>  | 上次修改的地方                   |
| <code>\`^</code>  | 上次插入的地方                   |
| <code>\`[</code>  | 上次修改或复制的起始位置         |
| <code>\`]</code>  | 上次修改或复制的起始位置         |
| <code>\`<</code>  | 上次高亮选区的起始位置           |
| <code>\`></code>  | 上次高亮选区的结束位置           |

`%`：允许我们在一组开、闭括号间跳转。在修改括号的操作中，可以先用该命令，进行一次跳转，修改好一侧的括号后，可以利用 <code>\`\`</code> 命令跳回另一侧括号，进行修改即可。

### 在文件间跳转

部分跳转动作命令：

| 命令                                  | 用途                            |
| ------------------------------------- | ------------------------------- |
| `[count]G`                            | 跳转到指定的行号                |
| `/pattern<CR>`/`?pattern<CR>`/`n`/`N` | 跳转到下一个/上一个模式出现之处 |
| `%`                                   | 跳转到匹配的括号所在之处        |
| `(`/`)`                               | 跳转到上一句/下一句的开头       |
| `{`/`}`                               | 跳转到上一段/下一段的开头       |
| `H`/`M`/`L`                           | 跳到屏幕最上方/正中间/最下方    |
| `gf`                                  | 跳转到光标下的文件名            |
| `<C-]>`                               | 跳转到光标下关键字的定义之处    |
| <code>\`{mark}</code>/`'{mark}`       | 跳转到一个位置标记              |

`Vim` 会记录跳转前后的位置，`<C-o>` 命令能回退，而 `<C-i>` 命令能前进。大范围的动作命令会被当成跳转，但小范围的动作命令则只能算移动。例如面向字符及面向的单词的动作就不算。

每当对文档做出修改后，`Vim` 都会记录当时光标所在的位置。可以利用 `g;` 和 `g,` 命令反向或正向遍历改变列表。

<code>\`.</code>：总是指向上次修改的位置。

<code>\`^</code>：记录上次退出插入模式时光标所在的位置。

`gi`：会用 <code>\`^</code> 标记恢复光标位置，并切换到插入模式。

`gf`：会尝试打开当前光标处的字符串所对应的文件，类似于超链接。可通过设置 `suffixesadd` 和 `path` 修正错误。

一般来说，要养成在使用与 quickfix 列表有关的命令前，如 `:grep`、`:vimgrep` 及 `:make`，设置全局标记的习惯。另外，在执行与缓冲区列表或参数列表有关的命令前，如 `:args {arglist}` 和 `:argdo`，也要设置全局标记。

## 寄存器

### 复制与粘贴

`xp`：可用于调换光标之后的两个字符。

`ddp`：可用于调换当前行和它的下一行。

`""`：无名寄存器。若没有指定要使用的寄存器，`Vim` 将缺省使用无名寄存器。为了显式地引用该寄存器，得使用两个双引号。例如，`""p` 完全等同于 `p` 命令。

`x`、`s`、`d{motion}`、`c{motion}`与`y{motion}`命令（以及它们对应的大写命令）都会覆盖无名寄存器中的内容。无论哪一种情况，都可以通过加 `"{register}` 前缀来指定另外一个寄存器。

`"0`：当使用 `y{motion}` 命令时，要复制的文本不仅会被拷贝到无名寄存器中，而且也被拷贝到了复制专用寄存器中，后者可用数字 0 加以引用。
`"a-"z`：有名寄存器。用小写字母引用有名寄存器，会覆盖该寄存器的原有内容，而换用大写字母的话，则会将新内容添加到该寄存器的原有内容之后。

`"_`：黑洞寄存器。该寄存器是个有去无回的地方。

`"+`：系统剪贴板，前面的寄存器都是 `Vim` 内部的，但是该寄存器与系统剪贴板相同。

`"=`：表达式寄存器，当从表达式寄存器获取内容时，`Vim` 将跳到命令行模式，并显示提示符 `=`。这时，可以输入一段 `Vim` 脚本表达式并按 `<CR>` 执行，如果返回的是字符串（或者可以被强制转换成字符串的数据），`Vim` 将会使用它。

只读寄存器：

| 寄存器 | 内容               |
| ------ | ------------------ |
| `"%`   | 当前文件名         |
| `"#`   | 轮换文件名         |
| `".`   | 上次插入的文本     |
| `":`   | 上次执行的 Ex 命令 |
| `"/`   | 上次查找的模式     |

在可视模式下使用 `p` 命令，`Vim` 将用我们指定的寄存器内容来替换高亮选区中的文本。

> 注：此操作后，无名寄存器包含的是被覆盖的内容。可利用该特点结合跳转标记 `mm` 和 <code>\`m</code> 完成两个词的交换。
>
> 删除第一个词(`diw`)—设置标记(`mm`)—移至第二个词(`{motion}`)—进入可视模式高亮第二个词(`viw`)—粘贴(`p`)—跳转标记(<code>\`m</code>)—粘贴(`p`)

粘贴面向字符的区域：可以先复制单词(`yiw`)—移至需要替换的词(`{motion}`)—使用组合命令(`ciw<C-r>0<Esc>`)来完成，之后还可以利用 `.` 命令进行重复替换。

粘贴面向行的区域：则可以使用 `p` 和 `P` 分别把它们粘贴至当前行的上一行或下一行。

使用系统粘贴命令时，可能会出现一些缩进错误，可以通过设置 `paste` 选项来解决，但是使用完之后要再次关闭该选项。或者可以利用普通模式下的 `"+p` 命令来粘贴加号寄存器中的内容，可以规避前面的选项设置。

### 宏

宏允许我们把一段修改序列录制下来，用于之后的回放。

`q`：即使宏“录制”按钮，也是“停止”按钮。为了录制我们的按键操作，一开始需要按 `q{register}`，从而指定一个用于保存宏的寄存器。

`@{register}`：执行指定寄存器的内容。

`@@`：重复最近调用过的宏。

> 黄金法则：在录制一个宏时，要确保每条命令都可被重复执行。

以并行方式执行宏：可以使用 `:[range] normal @{register}` 命令对区域内的每一行执行这个宏。

以并行的方式在多处执行宏更为健壮。但如果宏在执行时遇到一处错误，而我们正想利用这些警告更正错误时，以串行、多次的方式执行宏可以更容易定位出问题所在。

`:reg {register}`：查看寄存器 {register} 中的内容。

可以通过 `q{REGISTER}` 方式对 {register} 中的宏内容进行追加。

利用 `argdo normal @{register}` 命令在一组文件中执行宏。

将宏结合 `Vim` 命令行脚本，例如 `let i=0`、`let i+=1`，配合 `<C-r>=i` 可以动态改变内容。

编辑宏：先将记录宏的寄存器中的内容复制到文档中，然后进行编辑，最后用面向字符的复制操作把这些字符从文档复制回寄存器中。

## 模式 (pattern)

### 按模式匹配及按原义匹配

使用元字符 `\c` 和 `\C`，可以覆盖 `Vim` 缺省的大小写敏感性设置。小写字母 `\c` 会让查找模式忽略大小写，而大写字母 `\C` 则会强制区分大小写。

`Vim` 缺省使用 `magic` 搜索模式。方括号缺省具有特殊含义，因此不用转义。圆括号无论开闭，都必须转义。花括号只需为开括号转义，而与之对应的闭括号则不用。

`\v` 模式开关可以统一所有特殊符号的规则。该元字符将会激活 `very magic` 搜索模式，即假定除 \_ 、大小写字母以及数字 0 到 9 之外的所有字符都具有特殊含义。

`\x` 表示完整的字符集 `[0-9a-fA-F]`。

`\V` 原义开关可以激活 `very nomagic` 搜索模式。`\V` 会使得其后的模式中只有反斜杠有特殊的意义。

`/\v<(\w+)\_s+\1>` 可以用来匹配重复单词的正则表达式。

任何圆括号内部的匹配文本都会被自动保存到一个临时的仓库。我们可以用 `\1` 引用这段被捕获的文本。如果模式中包含不止一组圆括号，则可以用 `\1`、`\2`，直到 `\9`，引用被每对 `()` 捕获的子匹配。另外，不论模式中是否使用了圆括号，元字符 `\0` 永远会引用整个匹配。

`<pattern>`：单词定界符，指定了单词从哪里开始到哪里结束。

在 `\v` 搜索模式下，如果不想使用圆括号的分组功能，可以在其前面加上 `%` 即可，就不会将括号内的内容赋给寄存器。

界定匹配的边界，元字符 `\zs` 标志着一个匹配的开始，而元字符 `\ze` 则用来界定匹配的结束。将二者相结合，可以让我们定义一个模式匹配一个较大的文本范围，然后再收窄匹配范围。

例如，`/\v"[^"]+"<CR>` 将查找所有由双引号包裹起来的字串，同时被高亮。但是 `/\v"\zs[^"]+\ze"<CR>` 同样会查找所有由双引号包裹起来的字串，但是只有双引号内部的内容才会被高亮，而不是包括双引号的全部。

> 注：尽管引号被排除在匹配之外，但它们仍然是模式中的关键部分。

对于无论哪种查找方式，都需要转义的反斜杆字符，可以通过 `Vim` 脚本中库函数 `escape({string}, {chars})` 来解决。例如 `escape(@{register}, '/\')` 会为每个 / 与 \ 加上反斜杠前缀。如果是反向查找，则要换用 `escape(@{register}, '?\')`。可以利用命令 `escape(@{register}, getcmdtype().'\')` 来统一上述两个命令。

### 查找

用于重复一次查找的选项：

| 命令    | 用途                                   |
| ------- | -------------------------------------- |
| `n`     | 跳至下一处匹配，保持查找方向与偏移不变 |
| `N`     | 跳至上一处匹配，保持查找方向与偏移不变 |
| `/<CR>` | 正向跳转至相同模式的下一处匹配         |
| `?<CR>` | 反向跳转至相同模式的下一处匹配         |

创建用于关闭高亮功能的快捷键：`nnoremap <silent> <C-l> :<C-u>nohlsearch<CR><C-l>`。`<C-l>` 通常用于清除并重绘显示屏，而新的映射项，是在原有基础上增加了暂时关闭查找高亮的功能。

`:%s///gn`：可以统计当前文档中的匹配个数。

`/pattern/e<CR>`：进行查找时，会将光标置于查找匹配的结尾。

`//e<CR>`：当把查找域留空时，`Vim` 将重用上一次的查找模式，因此，该命令将使用偏移重复上一次查找。

`/\v'(([^']|'\w)+)`：可用于匹配所有被单引号包裹的内容。

查找当前选中的文本（`*`正向查找，`#`反向查找）：

```vim
xnoremap * :<C-u>call <SID>VSetSearch()<CR>/<C-R>=@/<CR><CR>
xnoremap # :<C-u>call <SID>VSetSearch()<CR>?<C-R>=@/<CR><CR>

fucntion! s:VSetSearch()
    let temp = @s
    norm! gv"sy
    let @/ = '\V' . substitute(escape(@s, '/\'), '\n', '\\n', 'g')
    let @s = temp
endfunction
```

### 替换

`:[range]s[ubstitute]/{pattern}/{string}/{flags}`：一条完整的 `substitute` 命令。

标志位（flags）：

| 标志位 | 说明                                         |
| ------ | -------------------------------------------- |
| `g`    | 在全局范围内执行，即可以修改一行内的所有匹配 |
| `c`    | 确认或拒绝每一处修改                         |
| `n`    | 抑制正常的替换行为                           |
| `e`    | 屏蔽错误提示                                 |
| `&`    | 重用上一次 `substitute` 命令所用过的标志位   |

替换域中的特殊字符：

| 符号             | 描述                                                          |
| ---------------- | ------------------------------------------------------------- |
| `\r`             | 插入一个换行符                                                |
| `\t`             | 插入一个制表符                                                |
| `\\`             | 插入一个反斜杠                                                |
| `\1`             | 插入第 1 个子匹配                                             |
| `\2`             | 插入第 2 个子匹配（以此类推，最多到 `\9` ）                   |
| `\0`             | 插入匹配模式的所有内容                                        |
| `&`              | 插入匹配模式的所有内容                                        |
| `~`              | 使用上一次调用 `:substitute` 时的 `{string}`                  |
| `\={Vim Script}` | 执行 `{Vim Script}` 表达式，并将返回的结果作为替换 `{string}` |

尽量将查找任务与替换任务分离，这样可以确保修改文档的准确性。但是这样操作有一个弊端，任务分离会致使这两组信息被单独存放，从而导致当再想重用之前的 `substitute` 命令时，遇到困难，可以通过在执行任务时弃用 `/` 留空方式选择 `/<C-r>/` 的方式来解决这个问题。

如果直接输入 `<C-r>{register}` 可以将寄存器的内容插入到命令行，当将其粘贴到 `substitute` 命令的替换域时，会存在没有对特殊含义字符进行转义的问题。可以通过简单地引用某个寄存器的方式来解决，也就是 `\=@{register}`。

`g&`：可在整个文件的范围内重复上条命令，等同于 `:%s//~/&`：用同样的标志位、同样的替换字符串、同样的查找模式以及新的执行范围 `%`，重复上一次 `substitute` 命令。

`:&&`：前一个 `&` 作为 Ex 命令 `:&` 的组成部分，用作重复上一次的 `:substitute` 命令，而第二个 `&` 则会重用上一次 `:s` 命令的标志位。因此，该命令为重新执行上一次的替换操作。具体来说，`:&&` 命令本身只作用于当前行。

### global 命令

`:global` 命令允许我们在某个指定模式的所有匹配行上运行 Ex 命令。通常采用的方式为 `:[range] global[!] /{pattern}/ [cmd]`。在缺省的情况下，`:global` 命令的作用范围是整个文件。`[cmd]` 可以是除 `:global` 命令之外的任何 Ex 命令。如果不指定任何 `[cmd]`，将缺省使用 `:print`。

`:global!` 或 `:vglobal`：反转 `:global` 命令，将指示 `Vim` 在没有匹配指定模式的行上执行 `[cmd]`。

`:g/{start}/ .,{finish} [cmd]`：对从 `{start}` 开始，到 `{finish}` 结束的所有文本行，执行指定的 `[cmd]`。

`:g/{/ .+1,/}/-1 sort`：模式 `{` 会匹配每个 `{}` 块的起始行，`:sort` 会从匹配行的下一行到 `{}` 块结尾的上一行区间内执行。

## 工具

使用 `ctags` 工具进行代码浏览时的可用命令：

| 命令               | 用途                                                                                                               |
| ------------------ | ------------------------------------------------------------------------------------------------------------------ |
| `<C-]>`            | 跳转到匹配当前光标所在关键字的第一处标签                                                                           |
| `g<C-]>`           | 如果有多处标签可以匹配当前光标所在的关键字，提示用户指定一处进行跳转。如果只有一处匹配，则不会提示，直接进行跳转。 |
| `:tag {keyword}`   | 跳转到匹配 `{keyword}` 的第一处标签                                                                                |
| `:tjump {keyword}` | 提示用户从匹配 `{keyword}` 的多处标签中指定一处进行跳转。如果只有一处匹配，则不会提示，直接进行跳转。              |
| `:pop` 或 `<C-t>`  | 反向遍历标签历史                                                                                                   |
| `:tag`             | 正向遍历标签历史                                                                                                   |
| `:tnext`           | 跳转到下一处匹配的标签                                                                                             |
| `:tprev`           | 跳转到上一处匹配的标签                                                                                             |
| `:tfirst`          | 跳转到第一处匹配的标签                                                                                             |
| `:tlast`           | 跳转到最后一处匹配的标签                                                                                           |
| `:tselect`         | 提示用户从标签匹配列表中选择一项进行跳转                                                                           |

利用 `quickfix` 工具记录一组针对单个或多个文件内容的位置信息，同时位置列表也有类似的命令，不同的是 `quickfix` 列表只能有一个，而位置列表则是任意。`:make`、`:grep` 以及 `:vimgrep` 会使用 `quickfix` 列表，而 `:lmake`、`:lgrep`以及`:lvimgrep` 将使用位置列表。

`quickfix` 列表操作命令：

| 命令      | 用途                         |
| --------- | ---------------------------- |
| `:cnext`  | 跳转到下一项                 |
| `:cprev`  | 跳转到上一项                 |
| `:cfirst` | 跳转到第一项                 |
| `:clast`  | 跳转到最后一项               |
| `:cnfile` | 跳转到下一个文件中的第一项   |
| `:cpfile` | 跳转到上一个文件中的最后一项 |
| `:cc N`   | 跳转到第 n 项                |
| `:copen`  | 打开 quickfix 窗口           |
| `:cclose` | 关闭 quickfix 窗口           |

> 注：操作位置列表则是将上表中的 `:c` 开头换成 `:l`。

当我们更新 `quickfix` 列表时，`Vim` 并不会覆盖之前的内容，而是将使用过的 `quickfix` 列表结果保存起来，方便回溯。

`:colder`：可以回溯 `quickfix` 列表之前的某个版本。

`:cnewer`：则会回到较新的列表。

触发 `Vim` 自动补全的方法：

| 命令         | 补全类型         |
| ------------ | ---------------- |
| `<C-n>`      | 普通关键字       |
| `<C-x><C-n>` | 当前缓冲区关键字 |
| `<C-x><C-i>` | 包含文件关键字   |
| `<C-x><C-]>` | 标签文件关键字   |
| `<C-x><C-k>` | 字典查找         |
| `<C-x><C-l>` | 整行补全         |
| `<C-x><C-f>` | 文件名补全       |
| `<C-x><C-o>` | 全能（Omni）补全 |

可供自动补全弹出式菜单使用的命令：

| 按键操作          | 作用                                              |
| ----------------- | ------------------------------------------------- |
| `<C-n>`           | 使用来自补全列表的下一个匹配项（next 匹配项）     |
| `<C-p>`           | 使用来自补全列表的上一个匹配项（previous 匹配项） |
| `<Down>`          | 选择来自补全列表的下一个匹配项                    |
| `<Up>`            | 选择来自补全列表的上一个匹配项                    |
| `<C-y>`           | 确认使用当前选中的匹配项（yes）                   |
| `<C-e>`           | 还原最早输入的文本（从自动补全中 exit）           |
| `<C-h>` 和 `<BS>` | 从当前匹配项中删除一个字符                        |
| `<C-l>`           | 从当前匹配项中增加一个字符                        |
| `{char}`          | 中止自动补全并插入字符 `{char}`                   |

在普通模式下操作 `Vim` 拼写检查器的基本命令：

| 命令  |               用途               |
| ---- | ------------------------------- |
| `]s`  | 跳到下一处拼写错误                |
| `[s`  | 跳到上一处拼写错误                |
| `z=`  | 为当前单词提供更正建议             |
| `zg`  | 把当前单词添加到拼写文件中         |
| `zw`  | 把当前单词从拼写文件中删除         |
| `zug` | 撤销针对当前单词的 `zg` 或 `zw` 命令 |

![VIM](https://gitee.com/KivenC/chaos/raw/master/upload_images/20200808152713.png)

[VIM.svg](_v_attachments/20200808132345545_73/VIM.svg)

## 参考

1. Drew Neil, 杨源, 车文隆. Vim 实用技巧[M]. 2014.
